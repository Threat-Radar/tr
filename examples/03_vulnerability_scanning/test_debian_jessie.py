"""
Test CVE matching against Debian 8 (Jessie) - known vulnerable image.

Debian 8 reached EOL in June 2020 and contains many unpatched vulnerabilities.
This is a good test case for validating our improved matching.
"""
from threat_radar.core.container_analyzer import ContainerAnalyzer
from threat_radar.core.nvd_client import NVDClient
from threat_radar.core.cve_matcher import CVEMatcher
from threat_radar.utils import docker_analyzer
import json
from datetime import datetime


def test_debian_jessie():
    """Scan Debian 8 (Jessie) which has known vulnerabilities."""

    print("=" * 70)
    print("VULNERABILITY SCAN: Debian 8 (Jessie) - EOL Distribution")
    print("=" * 70)

    # Debian 8 (Jessie) - EOL since June 2020
    image = "debian:8"

    print(f"\nTarget Image: {image}")
    print("Note: Debian 8 reached End-of-Life in June 2020")
    print()

    # Step 1: Analyze container
    print("[1/4] Pulling and analyzing Docker image...")
    with docker_analyzer() as analyzer:
        image_name, tag = image.split(':')
        analysis = analyzer.import_container(image_name, tag)

    print(f"     ‚úì Found {len(analysis.packages)} packages")
    print(f"     ‚úì Distribution: {analysis.distro} {analysis.distro_version}")
    print(f"     ‚úì Architecture: {analysis.architecture}")

    # Show critical packages
    print(f"\nCritical System Packages:")
    important_packages = {
        'openssl', 'libssl', 'bash', 'glibc', 'libc6',
        'libgnutls', 'libcurl', 'perl', 'python'
    }
    for pkg in analysis.packages:
        pkg_base = pkg.name.split('-')[0]  # Handle lib* packages
        if pkg.name in important_packages or pkg_base in important_packages:
            print(f"  - {pkg.name:20s} {pkg.version}")

    # Step 2: Fetch CVEs for vulnerable packages
    print(f"\n[2/4] Fetching CVEs for key packages...")
    client = NVDClient()

    all_cves = []

    # Target specific packages known to have CVEs in Debian 8
    search_terms = {
        'openssl': 20,      # Heartbleed and others
        'bash': 15,         # Shellshock
        'glibc': 20,        # Ghost and others
        'gnutls': 15,       # Various TLS issues
        'curl': 15,         # libcurl vulnerabilities
        'perl': 10,         # Perl vulnerabilities
    }

    for keyword, limit in search_terms.items():
        print(f"     Fetching {keyword} CVEs...")
        try:
            cves = client.search_cves(keyword=keyword, results_per_page=limit)
            all_cves.extend(cves)
            print(f"     ‚úì Found {len(cves)} CVEs")
        except Exception as e:
            print(f"     ‚ö† Error: {e}")

    client.close()

    # Remove duplicates
    unique_cves = {cve.cve_id: cve for cve in all_cves}.values()
    cves = list(unique_cves)

    print(f"\n     Total unique CVEs loaded: {len(cves)}")

    # Step 3: Match with improved settings
    print(f"\n[3/4] Matching packages against vulnerabilities...")
    print(f"     Using improved matching with:")
    print(f"       - Confidence threshold: 0.75")
    print(f"       - Max CVE age: 15 years")
    print(f"       - Filter disputed CVEs: Yes")

    matcher = CVEMatcher(
        min_confidence=0.75,
        max_cve_age_years=15,
        filter_disputed=True
    )
    matches = matcher.bulk_match_packages(analysis.packages, cves)

    vulnerable_count = len(matches)
    total_vulns = sum(len(m) for m in matches.values())

    print(f"     ‚úì Found {vulnerable_count} vulnerable packages")
    print(f"     ‚úì Total vulnerabilities detected: {total_vulns}")

    # Step 4: Display and analyze results
    print(f"\n[4/4] Vulnerability Report & Analysis:")
    print("=" * 70)

    if matches:
        print("\nVULNERABILITY FINDINGS")
        print("=" * 70)

        # Sort by severity
        severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, None: 4}

        validation_notes = []

        for pkg_name in sorted(matches.keys()):
            pkg_matches = matches[pkg_name]

            # Sort matches by severity
            pkg_matches.sort(key=lambda m: (
                severity_order.get(m.cve.severity, 4),
                -(m.cve.cvss_score or 0)
            ))

            # Find package version
            pkg_version = None
            for pkg in analysis.packages:
                if pkg.name == pkg_name:
                    pkg_version = pkg.version
                    break

            print(f"\nüì¶ Package: {pkg_name} {pkg_version or ''}")
            print(f"   Vulnerabilities: {len(pkg_matches)}")

            # Show top 3 for each package
            for i, match in enumerate(pkg_matches[:3], 1):
                severity_icon = {
                    "CRITICAL": "üî¥",
                    "HIGH": "üü†",
                    "MEDIUM": "üü°",
                    "LOW": "üü¢"
                }.get(match.cve.severity, "‚ö™")

                print(f"\n   {severity_icon} [{i}] {match.cve.cve_id}")
                print(f"       Severity: {match.cve.severity or 'N/A'}")
                print(f"       CVSS Score: {match.cve.cvss_score or 'N/A'}")
                print(f"       Confidence: {match.confidence:.0%}")
                print(f"       Match: {match.match_reason}")

                # Validation flag
                validation_flag = ""
                if match.version_match:
                    print(f"       ‚úì Version is in vulnerable range")
                    validation_flag = "‚úÖ TRUE POSITIVE (version match)"
                else:
                    print(f"       ‚ö† Name match only (version not in range)")
                    validation_flag = "‚ö†Ô∏è  NEEDS REVIEW (no version match)"

                # Check for potential false positives
                if match.confidence < 0.85:
                    validation_flag += " - Low confidence"

                # Truncate description
                desc = match.cve.description
                if len(desc) > 100:
                    desc = desc[:100] + "..."
                print(f"       {desc}")

                # Collect validation notes
                validation_notes.append({
                    "package": pkg_name,
                    "version": pkg_version,
                    "cve": match.cve.cve_id,
                    "confidence": match.confidence,
                    "version_match": match.version_match,
                    "match_reason": match.match_reason,
                    "validation": validation_flag
                })

            if len(pkg_matches) > 3:
                print(f"\n   ... and {len(pkg_matches) - 3} more vulnerabilities")

        # Summary statistics
        print("\n" + "=" * 70)
        print("SUMMARY & VALIDATION")
        print("=" * 70)

        severity_breakdown = {}
        for pkg_matches in matches.values():
            for match in pkg_matches:
                sev = match.cve.severity or "UNKNOWN"
                severity_breakdown[sev] = severity_breakdown.get(sev, 0) + 1

        print(f"\nImage: {image}")
        print(f"Total Packages Scanned: {len(analysis.packages)}")
        print(f"Vulnerable Packages: {vulnerable_count}")
        print(f"Total Vulnerabilities: {total_vulns}")

        print(f"\nSeverity Breakdown:")
        for sev in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "UNKNOWN"]:
            count = severity_breakdown.get(sev, 0)
            if count > 0:
                print(f"  {sev:8s}: {count:3d}")

        # Validation analysis
        print(f"\n" + "=" * 70)
        print("VALIDATION ANALYSIS")
        print("=" * 70)

        true_positives = [n for n in validation_notes if n["version_match"]]
        needs_review = [n for n in validation_notes if not n["version_match"]]
        high_confidence = [n for n in validation_notes if n["confidence"] >= 0.90]
        medium_confidence = [n for n in validation_notes if 0.80 <= n["confidence"] < 0.90]
        low_confidence = [n for n in validation_notes if n["confidence"] < 0.80]

        print(f"\n‚úÖ High Confidence Matches (‚â•90%): {len(high_confidence)}")
        print(f"‚ö†Ô∏è  Medium Confidence (80-90%): {len(medium_confidence)}")
        print(f"‚ùå Low Confidence (<80%): {len(low_confidence)}")

        print(f"\n‚úÖ Version Match Confirmed: {len(true_positives)}")
        print(f"‚ö†Ô∏è  Name Match Only: {len(needs_review)}")

        if low_confidence:
            print(f"\n‚ùå LOW CONFIDENCE FINDINGS (Potential False Positives):")
            for note in low_confidence[:5]:
                print(f"   - {note['package']} ‚Üí {note['cve']}")
                print(f"     Confidence: {note['confidence']:.0%}, {note['match_reason']}")

        # Generate detailed report
        report = {
            "scan_timestamp": datetime.now().isoformat(),
            "image": image,
            "distribution": f"{analysis.distro} {analysis.distro_version}",
            "architecture": analysis.architecture,
            "total_packages": len(analysis.packages),
            "vulnerable_packages": vulnerable_count,
            "total_vulnerabilities": total_vulns,
            "severity_breakdown": severity_breakdown,
            "validation_summary": {
                "high_confidence": len(high_confidence),
                "medium_confidence": len(medium_confidence),
                "low_confidence": len(low_confidence),
                "version_match": len(true_positives),
                "name_only_match": len(needs_review)
            },
            "findings": []
        }

        # Add detailed findings with validation
        for note in validation_notes:
            report["findings"].append({
                "package": note["package"],
                "package_version": note["version"],
                "cve_id": note["cve"],
                "confidence": round(note["confidence"], 2),
                "version_match": note["version_match"],
                "match_reason": note["match_reason"],
                "validation": note["validation"]
            })

        # Save report
        import os
        output_dir = os.path.join(os.path.dirname(__file__), '..', 'output')
        os.makedirs(output_dir, exist_ok=True)

        report_file = os.path.join(output_dir, "debian_8_vulnerability_report.json")
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)

        print(f"\nüìÑ Detailed report saved to: {report_file}")

        print("\n" + "=" * 70)
        print("‚úÖ SCAN COMPLETE")
        print("=" * 70)

    else:
        print("\n‚úÖ No vulnerabilities detected")
        print("   (Unexpected - Debian 8 is EOL and should have CVEs)")

    print()


if __name__ == "__main__":
    print("\n" + "=" * 70)
    print("THREAT RADAR - DEBIAN 8 VULNERABILITY TEST")
    print("=" * 70)
    print()
    print("Testing improved CVE matching against Debian 8 (Jessie).")
    print("This EOL distribution should have legitimate vulnerabilities.")
    print()

    try:
        test_debian_jessie()

        print("\nüí° Analysis Complete:")
        print("   - Review the validation analysis above")
        print("   - Check for any low confidence matches")
        print("   - Verify version matches for high-severity CVEs")

    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Scan interrupted by user")
    except Exception as e:
        print(f"\n\n‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
