"""
Scan a known vulnerable Docker image.

This example scans older versions of popular images that are known to contain
vulnerabilities, demonstrating the full vulnerability detection workflow.
"""
from threat_radar.core.container_analyzer import ContainerAnalyzer
from threat_radar.core.cve_database import CVEDatabase
from threat_radar.core.cve_matcher import CVEMatcher
from threat_radar.utils import docker_analyzer
import json
from datetime import datetime


def scan_vulnerable_image():
    """Scan an older image known to have vulnerabilities."""

    # Use an older Ubuntu version (known to have CVEs)
    image = "ubuntu:18.04"

    print("=" * 70)
    print("VULNERABILITY SCAN: Older Ubuntu Image with Known CVEs")
    print("=" * 70)

    print(f"\nTarget Image: {image}")
    print("Note: Using older image version to demonstrate vulnerability detection")
    print()

    # Step 1: Pull and analyze the image
    print("[1/5] Pulling and analyzing Docker image...")
    print("     (This may take a few minutes on first run)")

    with docker_analyzer() as analyzer:
        image_name, tag = image.split(':')
        analysis = analyzer.import_container(image_name, tag)

    print(f"     ✓ Found {len(analysis.packages)} packages")
    print(f"     ✓ Distribution: {analysis.distro} {analysis.distro_version}")
    print(f"     ✓ Architecture: {analysis.architecture}")

    # Step 2: Update CVE database
    print("\n[2/5] Updating CVE database...")
    print("     (Fetching recent vulnerabilities from NVD)")

    db = CVEDatabase()
    count = db.update_from_nvd(days=120, force=False)  # Get last 4 months of CVEs

    stats = db.get_stats()
    print(f"     ✓ Database now contains {stats['total_cves']:,} CVEs")
    print(f"     ✓ Added/updated {count} CVEs in this run")

    # Step 3: Load CVEs for matching
    print("\n[3/5] Loading CVEs from database...")

    # Get a broader set of CVEs to increase match probability
    all_cves = []

    # Get CVEs for common packages
    for keyword in ['openssl', 'glibc', 'systemd', 'util-linux', 'bash', 'coreutils']:
        cves = db.search_cves(keyword=keyword, limit=200)
        all_cves.extend(cves)

    # Also get high-severity CVEs
    high_severity = db.search_cves(severity="HIGH", limit=500)
    critical_severity = db.search_cves(severity="CRITICAL", limit=500)

    all_cves.extend(high_severity)
    all_cves.extend(critical_severity)

    # Remove duplicates
    unique_cves = {cve.cve_id: cve for cve in all_cves}.values()
    cves = list(unique_cves)

    print(f"     ✓ Loaded {len(cves)} unique CVEs for matching")

    # Step 4: Match packages against CVEs
    print("\n[4/5] Matching packages against vulnerabilities...")
    print("     (Using confidence threshold: 0.6 for broader detection)")

    matcher = CVEMatcher(min_confidence=0.6)  # Lower threshold for more matches
    matches = matcher.bulk_match_packages(analysis.packages, cves)

    vulnerable_count = len(matches)
    total_vulns = sum(len(m) for m in matches.values())

    print(f"     ✓ Found {vulnerable_count} vulnerable packages")
    print(f"     ✓ Total vulnerabilities detected: {total_vulns}")

    # Step 5: Display and save results
    print("\n[5/5] Generating vulnerability report...")

    if matches:
        # Display findings
        print("\n" + "=" * 70)
        print("VULNERABILITY FINDINGS")
        print("=" * 70)

        # Sort by severity
        severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, None: 4}

        for pkg_name in sorted(matches.keys()):
            pkg_matches = matches[pkg_name]

            # Sort matches by severity
            pkg_matches.sort(key=lambda m: (
                severity_order.get(m.cve.severity, 4),
                -(m.cve.cvss_score or 0)
            ))

            print(f"\n📦 Package: {pkg_name}")
            print(f"   Vulnerabilities: {len(pkg_matches)}")

            # Show top 3 for each package
            for i, match in enumerate(pkg_matches[:3], 1):
                severity_color = {
                    "CRITICAL": "🔴",
                    "HIGH": "🟠",
                    "MEDIUM": "🟡",
                    "LOW": "🟢"
                }.get(match.cve.severity, "⚪")

                print(f"\n   {severity_color} [{i}] {match.cve.cve_id}")
                print(f"       Severity: {match.cve.severity or 'N/A'}")
                print(f"       CVSS Score: {match.cve.cvss_score or 'N/A'}")
                print(f"       Confidence: {match.confidence:.0%}")
                print(f"       Reason: {match.match_reason}")

                # Truncate description
                desc = match.cve.description
                if len(desc) > 100:
                    desc = desc[:100] + "..."
                print(f"       Description: {desc}")

            if len(pkg_matches) > 3:
                print(f"\n   ... and {len(pkg_matches) - 3} more vulnerabilities")

        # Summary statistics
        print("\n" + "=" * 70)
        print("SUMMARY")
        print("=" * 70)

        severity_breakdown = {}
        for pkg_matches in matches.values():
            for match in pkg_matches:
                sev = match.cve.severity or "UNKNOWN"
                severity_breakdown[sev] = severity_breakdown.get(sev, 0) + 1

        print(f"\nImage: {image}")
        print(f"Total Packages Scanned: {len(analysis.packages)}")
        print(f"Vulnerable Packages: {vulnerable_count}")
        print(f"Total Vulnerabilities: {total_vulns}")

        print(f"\nSeverity Breakdown:")
        for sev in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "UNKNOWN"]:
            count = severity_breakdown.get(sev, 0)
            if count > 0:
                print(f"  {sev:8s}: {count:3d}")

        # Generate JSON report
        report = {
            "scan_timestamp": datetime.now().isoformat(),
            "image": image,
            "distribution": f"{analysis.distro} {analysis.distro_version}",
            "architecture": analysis.architecture,
            "total_packages": len(analysis.packages),
            "vulnerable_packages": vulnerable_count,
            "total_vulnerabilities": total_vulns,
            "severity_breakdown": severity_breakdown,
            "findings": []
        }

        # Add detailed findings
        for pkg_name, pkg_matches in matches.items():
            for match in pkg_matches:
                report["findings"].append({
                    "package": pkg_name,
                    "cve_id": match.cve.cve_id,
                    "severity": match.cve.severity,
                    "cvss_score": match.cve.cvss_score,
                    "cvss_vector": match.cve.cvss_vector,
                    "confidence": round(match.confidence, 2),
                    "version_match": match.version_match,
                    "match_reason": match.match_reason,
                    "description": match.cve.description,
                    "published_date": match.cve.published_date,
                    "cwe_ids": match.cve.cwe_ids,
                    "references": match.cve.references[:3] if match.cve.references else []
                })

        # Save report to output directory
        import os
        output_dir = os.path.join(os.path.dirname(__file__), '..', 'output')
        os.makedirs(output_dir, exist_ok=True)

        report_file = os.path.join(output_dir, f"vulnerability_report_{image.replace(':', '_')}.json")
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)

        print(f"\n📄 Detailed report saved to: {report_file}")

        # Also create a simple text summary
        summary_file = os.path.join(output_dir, f"vulnerability_summary_{image.replace(':', '_')}.txt")
        with open(summary_file, 'w') as f:
            f.write(f"VULNERABILITY SCAN SUMMARY\n")
            f.write(f"=" * 70 + "\n\n")
            f.write(f"Image: {image}\n")
            f.write(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Total Packages: {len(analysis.packages)}\n")
            f.write(f"Vulnerable Packages: {vulnerable_count}\n")
            f.write(f"Total Vulnerabilities: {total_vulns}\n\n")

            f.write("Severity Breakdown:\n")
            for sev in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
                count = severity_breakdown.get(sev, 0)
                if count > 0:
                    f.write(f"  {sev}: {count}\n")

            f.write(f"\n\nTop Vulnerabilities by Severity:\n")
            f.write("=" * 70 + "\n\n")

            # Get all CVEs sorted by severity and score
            all_findings = []
            for pkg_name, pkg_matches in matches.items():
                for match in pkg_matches:
                    all_findings.append((pkg_name, match))

            all_findings.sort(key=lambda x: (
                severity_order.get(x[1].cve.severity, 4),
                -(x[1].cve.cvss_score or 0)
            ))

            for pkg_name, match in all_findings[:20]:  # Top 20
                f.write(f"{match.cve.cve_id} - {match.cve.severity or 'N/A'} "
                       f"(CVSS: {match.cve.cvss_score or 'N/A'})\n")
                f.write(f"  Package: {pkg_name}\n")
                f.write(f"  {match.cve.description[:150]}...\n\n")

        print(f"📄 Summary saved to: {summary_file}")

        print("\n" + "=" * 70)
        print("✅ SCAN COMPLETE")
        print("=" * 70)

    else:
        print("\n✅ No vulnerabilities detected")
        print("   (Try scanning an even older image or adjusting confidence threshold)")

    db.close()


if __name__ == "__main__":
    print("\n" + "=" * 70)
    print("THREAT RADAR - VULNERABILITY SCANNING DEMO")
    print("=" * 70)
    print()
    print("This example demonstrates vulnerability detection by scanning")
    print("an older Ubuntu image (18.04) known to contain CVEs.")
    print()

    try:
        scan_vulnerable_image()

        print("\n💡 Tips:")
        print("   - Try scanning other old images: ubuntu:16.04, debian:9, centos:7")
        print("   - Adjust confidence threshold (0.5-0.9) to tune results")
        print("   - Use --severity flag to filter by severity level")
        print("   - Check the JSON report for detailed vulnerability data")

    except KeyboardInterrupt:
        print("\n\n⚠️  Scan interrupted by user")
    except Exception as e:
        print(f"\n\n❌ Error: {e}")
        import traceback
        traceback.print_exc()
        print("\nTroubleshooting:")
        print("  1. Ensure Docker is running: docker ps")
        print("  2. Check internet connection for NVD API")
        print("  3. See examples/TROUBLESHOOTING.md for more help")
