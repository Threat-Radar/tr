"""
Comprehensive CVE test against Debian 8 (Jessie).

Uses a broader CVE search to find actual vulnerabilities in this EOL distribution.
"""
from threat_radar.core.container_analyzer import ContainerAnalyzer
from threat_radar.core.nvd_client import NVDClient
from threat_radar.core.cve_matcher import CVEMatcher
from threat_radar.utils import docker_analyzer
import json
from datetime import datetime


def comprehensive_debian8_scan():
    """Comprehensive scan of Debian 8 with broad CVE coverage."""

    print("=" * 70)
    print("COMPREHENSIVE VULNERABILITY SCAN: Debian 8 (Jessie)")
    print("=" * 70)

    image = "debian:8"

    print(f"\nTarget Image: {image}")
    print("Note: Debian 8 reached EOL in June 2020")
    print()

    # Step 1: Analyze container
    print("[1/5] Pulling and analyzing Docker image...")
    with docker_analyzer() as analyzer:
        image_name, tag = image.split(':')
        analysis = analyzer.import_container(image_name, tag)

    print(f"     ✓ Found {len(analysis.packages)} packages")
    print(f"     ✓ Distribution: {analysis.distro} {analysis.distro_version}")
    print(f"     ✓ Architecture: {analysis.architecture}")

    # Show all packages
    print(f"\nAll Packages in Image:")
    for pkg in sorted(analysis.packages, key=lambda p: p.name)[:20]:
        print(f"  - {pkg.name:30s} {pkg.version}")
    if len(analysis.packages) > 20:
        print(f"  ... and {len(analysis.packages) - 20} more packages")

    # Step 2: Fetch CVEs - broader search
    print(f"\n[2/5] Fetching CVEs (broader search)...")
    client = NVDClient()

    all_cves = []

    # More comprehensive CVE search
    print("     Fetching high-profile CVEs...")

    # Get specific high-profile CVEs by ID
    known_cves = [
        'CVE-2014-6271',  # Shellshock
        'CVE-2014-0160',  # Heartbleed
        'CVE-2015-0235',  # GHOST
        'CVE-2016-5195',  # Dirty COW
    ]

    for cve_id in known_cves:
        try:
            print(f"     Fetching {cve_id}...")
            cve = client.get_cve_by_id(cve_id)
            if cve:
                all_cves.append(cve)
                print(f"     ✓ Found {cve_id}")
        except Exception as e:
            print(f"     ⚠ {cve_id}: {e}")

    # Broader keyword searches with more results
    search_terms = [
        ('bash', 20),
        ('openssl', 30),
        ('glibc', 30),
        ('gnu', 30),
        ('debian', 25),
    ]

    for keyword, limit in search_terms:
        print(f"     Searching '{keyword}' (up to {limit} CVEs)...")
        try:
            cves = client.search_cves(keyword=keyword, results_per_page=limit)
            all_cves.extend(cves)
            print(f"     ✓ Found {len(cves)} CVEs")
        except Exception as e:
            print(f"     ⚠ Error: {e}")

    client.close()

    # Remove duplicates
    unique_cves = {cve.cve_id: cve for cve in all_cves if cve}.values()
    cves = list(unique_cves)

    print(f"\n     Total unique CVEs loaded: {len(cves)}")

    # Step 3: Show CVE age distribution
    print(f"\n[3/5] CVE Age Distribution...")
    from collections import Counter
    cve_years = []
    for cve in cves:
        if cve.published_date:
            try:
                if isinstance(cve.published_date, str):
                    year = int(cve.published_date[:4])
                else:
                    year = cve.published_date.year
                cve_years.append(year)
            except:
                pass

    year_counts = Counter(cve_years)
    for year in sorted(year_counts.keys(), reverse=True)[:10]:
        print(f"     {year}: {year_counts[year]} CVEs")

    # Step 4: Match with improved settings
    print(f"\n[4/5] Matching packages against {len(cves)} CVEs...")
    print(f"     Using improved matching with:")
    print(f"       - Confidence threshold: 0.75")
    print(f"       - Max CVE age: 15 years")
    print(f"       - Filter disputed CVEs: Yes")

    matcher = CVEMatcher(
        min_confidence=0.75,
        max_cve_age_years=15,
        filter_disputed=True
    )
    matches = matcher.bulk_match_packages(analysis.packages, cves)

    vulnerable_count = len(matches)
    total_vulns = sum(len(m) for m in matches.values())

    print(f"     ✓ Found {vulnerable_count} vulnerable packages")
    print(f"     ✓ Total vulnerabilities detected: {total_vulns}")

    # Step 5: Display results with validation
    print(f"\n[5/5] Vulnerability Report:")
    print("=" * 70)

    if matches:
        print("\nVULNERABILITY FINDINGS")
        print("=" * 70)

        severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, None: 4}

        false_positives = []
        true_positives = []
        needs_review = []

        for pkg_name in sorted(matches.keys()):
            pkg_matches = matches[pkg_name]

            pkg_matches.sort(key=lambda m: (
                severity_order.get(m.cve.severity, 4),
                -(m.cve.cvss_score or 0)
            ))

            pkg_version = None
            for pkg in analysis.packages:
                if pkg.name == pkg_name:
                    pkg_version = pkg.version
                    break

            print(f"\n📦 Package: {pkg_name} {pkg_version or ''}")
            print(f"   Vulnerabilities: {len(pkg_matches)}")

            for i, match in enumerate(pkg_matches[:5], 1):
                severity_icon = {
                    "CRITICAL": "🔴",
                    "HIGH": "🟠",
                    "MEDIUM": "🟡",
                    "LOW": "🟢"
                }.get(match.cve.severity, "⚪")

                print(f"\n   {severity_icon} [{i}] {match.cve.cve_id}")
                print(f"       Severity: {match.cve.severity or 'N/A'}")
                print(f"       CVSS Score: {match.cve.cvss_score or 'N/A'}")
                print(f"       Confidence: {match.confidence:.0%}")
                print(f"       Match: {match.match_reason}")

                # Validation
                validation = ""
                if match.version_match and match.confidence >= 0.90:
                    print(f"       ✅ Version match confirmed")
                    validation = "TRUE POSITIVE"
                    true_positives.append((pkg_name, match.cve.cve_id, match.confidence))
                elif match.version_match:
                    print(f"       ⚠️  Version match, medium confidence")
                    validation = "LIKELY TRUE POSITIVE"
                    needs_review.append((pkg_name, match.cve.cve_id, match.confidence))
                else:
                    print(f"       ❌ No version match")
                    validation = "POTENTIAL FALSE POSITIVE"
                    false_positives.append((pkg_name, match.cve.cve_id, match.confidence))

                desc = match.cve.description
                if len(desc) > 100:
                    desc = desc[:100] + "..."
                print(f"       {desc}")
                print(f"       Validation: {validation}")

            if len(pkg_matches) > 5:
                print(f"\n   ... and {len(pkg_matches) - 5} more vulnerabilities")

        # Summary
        print("\n" + "=" * 70)
        print("SUMMARY & VALIDATION")
        print("=" * 70)

        severity_breakdown = {}
        for pkg_matches in matches.values():
            for match in pkg_matches:
                sev = match.cve.severity or "UNKNOWN"
                severity_breakdown[sev] = severity_breakdown.get(sev, 0) + 1

        print(f"\nImage: {image}")
        print(f"Total Packages Scanned: {len(analysis.packages)}")
        print(f"Vulnerable Packages: {vulnerable_count}")
        print(f"Total Vulnerabilities: {total_vulns}")

        print(f"\nSeverity Breakdown:")
        for sev in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "UNKNOWN"]:
            count = severity_breakdown.get(sev, 0)
            if count > 0:
                print(f"  {sev:8s}: {count:3d}")

        print(f"\n" + "=" * 70)
        print("VALIDATION BREAKDOWN")
        print("=" * 70)

        print(f"\n✅ TRUE POSITIVES (High Confidence + Version Match): {len(true_positives)}")
        for pkg, cve, conf in true_positives[:10]:
            print(f"   - {pkg:20s} → {cve} ({conf:.0%})")

        print(f"\n⚠️  NEEDS REVIEW (Version Match, Lower Confidence): {len(needs_review)}")
        for pkg, cve, conf in needs_review[:5]:
            print(f"   - {pkg:20s} → {cve} ({conf:.0%})")

        print(f"\n❌ POTENTIAL FALSE POSITIVES (No Version Match): {len(false_positives)}")
        for pkg, cve, conf in false_positives[:5]:
            print(f"   - {pkg:20s} → {cve} ({conf:.0%})")

        # Calculate metrics
        total_findings = len(true_positives) + len(needs_review) + len(false_positives)
        precision_estimate = (len(true_positives) / total_findings * 100) if total_findings > 0 else 0

        print(f"\n" + "=" * 70)
        print("QUALITY METRICS")
        print("=" * 70)
        print(f"\nEstimated Precision: {precision_estimate:.1f}%")
        print(f"High Confidence Matches: {len(true_positives)} / {total_findings}")
        print(f"False Positive Rate (est): {len(false_positives) / total_findings * 100:.1f}%")

        # Save report
        report = {
            "scan_timestamp": datetime.now().isoformat(),
            "image": image,
            "distribution": f"{analysis.distro} {analysis.distro_version}",
            "total_packages": len(analysis.packages),
            "total_cves_searched": len(cves),
            "vulnerable_packages": vulnerable_count,
            "total_vulnerabilities": total_vulns,
            "severity_breakdown": severity_breakdown,
            "validation": {
                "true_positives": len(true_positives),
                "needs_review": len(needs_review),
                "potential_false_positives": len(false_positives),
                "estimated_precision": round(precision_estimate, 2)
            },
            "findings": {
                "true_positives": [{"package": p, "cve": c, "confidence": conf} for p, c, conf in true_positives],
                "needs_review": [{"package": p, "cve": c, "confidence": conf} for p, c, conf in needs_review],
                "potential_false_positives": [{"package": p, "cve": c, "confidence": conf} for p, c, conf in false_positives],
            }
        }

        import os
        output_dir = os.path.join(os.path.dirname(__file__), '..', 'output')
        os.makedirs(output_dir, exist_ok=True)

        report_file = os.path.join(output_dir, "debian8_comprehensive_report.json")
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)

        print(f"\n📄 Detailed report saved to: {report_file}")

        print("\n" + "=" * 70)
        print("✅ SCAN COMPLETE")
        print("=" * 70)

    else:
        print("\n⚠️  No vulnerabilities detected")

    print()


if __name__ == "__main__":
    print("\n" + "=" * 70)
    print("THREAT RADAR - COMPREHENSIVE DEBIAN 8 TEST")
    print("=" * 70)
    print()

    try:
        comprehensive_debian8_scan()
    except KeyboardInterrupt:
        print("\n\n⚠️  Scan interrupted by user")
    except Exception as e:
        print(f"\n\n❌ Error: {e}")
        import traceback
        traceback.print_exc()
