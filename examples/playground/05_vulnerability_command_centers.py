#!/usr/bin/env python3
"""
Advanced Command Center Visualizations for Vulnerability Analysis
==================================================================

Creates multiple command center-style dashboards focusing on:
1. Critical Vulnerabilities mapped to Attack Paths
2. Package Risk Analysis with Attack Path Impact
3. Attack Vector Analysis (exploit types, CVEs, packages)
4. Remediation Priority Command Center

Each dashboard combines multiple synchronized views for comprehensive analysis.
"""

import json
import math
from pathlib import Path
import networkx as nx
from typing import List, Dict, Set, Tuple

from threat_radar.graph import NetworkXClient
from threat_radar.graph.models import AttackPath, AttackStep, ThreatLevel
from threat_radar.graph.queries import GraphAnalyzer
from threat_radar.visualization import NetworkGraphVisualizer

try:
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
except ImportError:
    print("‚ùå Error: Plotly is required for visualizations")
    print("Install with: pip install plotly")
    exit(1)


def get_vulnerability_severity_color(severity: str) -> str:
    """Get color for vulnerability severity."""
    severity_colors = {
        'critical': '#dc2626',  # Red
        'high': '#ea580c',      # Orange
        'medium': '#eab308',    # Yellow
        'low': '#3b82f6',       # Blue
        'negligible': '#6b7280' # Gray
    }
    return severity_colors.get(severity.lower(), '#6b7280')


def get_threat_level_color(threat_level: str) -> str:
    """Get color for attack path threat level."""
    threat_colors = {
        'critical': '#dc2626',
        'high': '#ea580c',
        'medium': '#eab308',
        'low': '#3b82f6'
    }
    return threat_colors.get(threat_level.lower(), '#6b7280')


def extract_vulnerabilities_from_graph(graph: nx.Graph) -> List[Dict]:
    """Extract all vulnerabilities from the graph with metadata."""
    vulnerabilities = []

    for node_id, node_data in graph.nodes(data=True):
        if node_data.get('node_type') == 'vulnerability':
            vuln = {
                'cve_id': node_data.get('cve_id', node_id),
                'severity': node_data.get('severity', 'unknown'),
                'cvss_score': node_data.get('cvss_score', 0.0),
                'description': node_data.get('description', ''),
                'packages': []  # Will fill this
            }

            # Find packages with this vulnerability
            for neighbor in graph.neighbors(node_id):
                neighbor_data = graph.nodes[neighbor]
                if neighbor_data.get('node_type') == 'package':
                    vuln['packages'].append({
                        'name': neighbor_data.get('name', neighbor_data.get('package_name', neighbor)),
                        'version': neighbor_data.get('version', 'unknown'),
                        'ecosystem': neighbor_data.get('ecosystem', 'unknown')
                    })

            vulnerabilities.append(vuln)

    return vulnerabilities


def extract_packages_from_graph(graph: nx.Graph) -> List[Dict]:
    """Extract all packages from the graph with vulnerability counts."""
    packages = []

    for node_id, node_data in graph.nodes(data=True):
        if node_data.get('node_type') == 'package':
            # Count vulnerabilities by severity
            vuln_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
            total_cvss = 0.0
            cves = []

            for neighbor in graph.neighbors(node_id):
                neighbor_data = graph.nodes[neighbor]
                if neighbor_data.get('node_type') == 'vulnerability':
                    severity = neighbor_data.get('severity', 'unknown').lower()
                    if severity in vuln_counts:
                        vuln_counts[severity] += 1
                    total_cvss += neighbor_data.get('cvss_score', 0.0)
                    cves.append(neighbor_data.get('cve_id', neighbor))

            package = {
                'name': node_data.get('name', node_data.get('package_name', node_id)),
                'version': node_data.get('version', 'unknown'),
                'ecosystem': node_data.get('ecosystem', 'unknown'),
                'vuln_counts': vuln_counts,
                'total_vulnerabilities': sum(vuln_counts.values()),
                'average_cvss': total_cvss / max(len(cves), 1),
                'cves': cves,
                'node_id': node_id  # Keep node_id for lookups
            }

            packages.append(package)

    # Sort by total vulnerabilities
    packages.sort(key=lambda p: p['total_vulnerabilities'], reverse=True)

    return packages


def map_vulnerabilities_to_paths(vulnerabilities: List[Dict], attack_paths: List[AttackPath]) -> Dict[str, List[str]]:
    """Map each CVE to the attack paths it appears in."""
    cve_to_paths = {}

    for path in attack_paths:
        for step in path.steps:
            for cve in step.vulnerabilities:
                if cve not in cve_to_paths:
                    cve_to_paths[cve] = []
                cve_to_paths[cve].append(path.path_id)

    return cve_to_paths


def create_critical_vulnerability_command_center(visualizer: NetworkGraphVisualizer,
                                                  attack_paths: List[AttackPath],
                                                  output_file: str):
    """
    Create command center focused on critical vulnerabilities and their attack path connections.

    Layout (2x2):
    - Top-left: Critical CVE list with attack path counts
    - Top-right: Attack path network showing critical CVEs
    - Bottom-left: CVE severity distribution pie chart
    - Bottom-right: Critical CVEs timeline (by CVSS score)
    """
    print("\n1Ô∏è‚É£  Creating Critical Vulnerability Command Center...")

    graph = visualizer.client.graph
    vulnerabilities = extract_vulnerabilities_from_graph(graph)

    # Filter to critical and high severity
    critical_vulns = [v for v in vulnerabilities if v['severity'].lower() in ['critical', 'high']]
    critical_vulns.sort(key=lambda v: v['cvss_score'], reverse=True)

    # Map CVEs to attack paths
    cve_to_paths = map_vulnerabilities_to_paths(vulnerabilities, attack_paths)

    # Create subplots
    fig = make_subplots(
        rows=2, cols=2,
        subplot_titles=(
            'Critical & High Severity CVEs',
            'Attack Path Network (Critical CVEs)',
            'Vulnerability Severity Distribution',
            'Critical CVEs by CVSS Score'
        ),
        specs=[
            [{'type': 'table'}, {'type': 'scatter'}],
            [{'type': 'pie'}, {'type': 'bar'}]
        ],
        vertical_spacing=0.12,
        horizontal_spacing=0.1
    )

    # 1. Critical CVE Table (top-left)
    table_data = {
        'CVE ID': [],
        'Severity': [],
        'CVSS': [],
        'Packages': [],
        'Attack Paths': []
    }

    for vuln in critical_vulns[:20]:  # Top 20
        table_data['CVE ID'].append(vuln['cve_id'])
        table_data['Severity'].append(vuln['severity'].upper())
        table_data['CVSS'].append(f"{vuln['cvss_score']:.1f}")
        table_data['Packages'].append(f"{len(vuln['packages'])} pkg(s)")
        table_data['Attack Paths'].append(f"{len(cve_to_paths.get(vuln['cve_id'], []))} path(s)")

    fig.add_trace(
        go.Table(
            header=dict(
                values=list(table_data.keys()),
                fill_color='#1e293b',
                font=dict(color='white', size=11),
                align='left'
            ),
            cells=dict(
                values=list(table_data.values()),
                fill_color='#0f172a',
                font=dict(color='#e2e8f0', size=10),
                align='left',
                height=25
            )
        ),
        row=1, col=1
    )

    # 2. Attack Path Network (top-right) - showing CVEs in paths
    pos = nx.spring_layout(graph, k=3, iterations=50, seed=42)

    # Only show critical CVEs and their connections
    critical_cve_ids = {v['cve_id'] for v in critical_vulns}

    # Nodes
    for node_id, node_data in graph.nodes(data=True):
        if node_data.get('node_type') == 'vulnerability' and node_data.get('cve_id') in critical_cve_ids:
            x, y = pos[node_id]
            severity = node_data.get('severity', 'unknown')
            color = get_vulnerability_severity_color(severity)

            fig.add_trace(
                go.Scatter(
                    x=[x], y=[y],
                    mode='markers',
                    marker=dict(size=12, color=color, line=dict(width=2, color='white')),
                    text=f"{node_data.get('cve_id', node_id)}<br>CVSS: {node_data.get('cvss_score', 0):.1f}",
                    hoverinfo='text',
                    showlegend=False
                ),
                row=1, col=2
            )

    # Edges
    for edge in graph.edges():
        if graph.nodes[edge[0]].get('node_type') == 'vulnerability' and \
           graph.nodes[edge[0]].get('cve_id') in critical_cve_ids:
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]

            fig.add_trace(
                go.Scatter(
                    x=[x0, x1, None], y=[y0, y1, None],
                    mode='lines',
                    line=dict(width=1, color='rgba(147, 51, 234, 0.3)'),
                    hoverinfo='none',
                    showlegend=False
                ),
                row=1, col=2
            )

    fig.update_xaxes(showgrid=False, showticklabels=False, zeroline=False, row=1, col=2)
    fig.update_yaxes(showgrid=False, showticklabels=False, zeroline=False, row=1, col=2)

    # 3. Severity Distribution Pie Chart (bottom-left)
    severity_counts = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0}
    for vuln in vulnerabilities:
        severity = vuln['severity'].title()
        if severity in severity_counts:
            severity_counts[severity] += 1

    fig.add_trace(
        go.Pie(
            labels=list(severity_counts.keys()),
            values=list(severity_counts.values()),
            marker=dict(colors=['#dc2626', '#ea580c', '#eab308', '#3b82f6']),
            textinfo='label+percent',
            textfont=dict(color='white', size=12),
            hovertemplate='%{label}: %{value} CVEs<extra></extra>'
        ),
        row=2, col=1
    )

    # 4. Critical CVEs Bar Chart (bottom-right)
    top_critical = critical_vulns[:15]

    fig.add_trace(
        go.Bar(
            x=[v['cvss_score'] for v in top_critical],
            y=[v['cve_id'] for v in top_critical],
            orientation='h',
            marker=dict(
                color=[get_vulnerability_severity_color(v['severity']) for v in top_critical],
                line=dict(width=1, color='white')
            ),
            text=[f"{v['cvss_score']:.1f}" for v in top_critical],
            textposition='outside',
            hovertemplate='%{y}<br>CVSS: %{x:.1f}<extra></extra>'
        ),
        row=2, col=2
    )

    fig.update_xaxes(title_text="CVSS Score", range=[0, 10.5], row=2, col=2)

    # Overall layout
    fig.update_layout(
        title=dict(
            text="üö® CRITICAL VULNERABILITY COMMAND CENTER",
            font=dict(size=24, color='#ef4444', family='monospace'),
            x=0.5,
            xanchor='center'
        ),
        showlegend=False,
        height=1200,
        width=2000,
        paper_bgcolor='#0a0a0a',
        plot_bgcolor='#0f172a',
        font=dict(color='white', family='monospace')
    )

    # Save
    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    fig.write_html(str(output_path))
    print(f"   ‚úì Saved: {output_path}")


def create_package_risk_command_center(visualizer: NetworkGraphVisualizer,
                                       attack_paths: List[AttackPath],
                                       output_file: str):
    """
    Create command center focused on package risk and attack path impact.

    Layout (2x2):
    - Top-left: Top risky packages table
    - Top-right: Package network showing vulnerability connections
    - Bottom-left: Package ecosystem distribution
    - Bottom-right: Packages enabling most attack paths
    """
    print("\n2Ô∏è‚É£  Creating Package Risk Command Center...")

    graph = visualizer.client.graph
    packages = extract_packages_from_graph(graph)

    # Map packages to attack paths
    # Attack paths go through containers/assets, so we need to find packages in those containers
    package_to_paths = {}

    # First, find which containers are in attack paths
    containers_in_paths = {}
    for path in attack_paths:
        for step in path.steps:
            node_data = graph.nodes.get(step.node_id, {})
            if node_data.get('node_type') == 'container':
                if step.node_id not in containers_in_paths:
                    containers_in_paths[step.node_id] = set()
                containers_in_paths[step.node_id].add(path.path_id)

    # Now map packages to paths through their containers
    for pkg_node_id, pkg_data in graph.nodes(data=True):
        if pkg_data.get('node_type') != 'package':
            continue

        pkg_name = pkg_data.get('name', pkg_data.get('package_name', pkg_node_id))

        # Find which container this package belongs to
        for neighbor in graph.neighbors(pkg_node_id):
            neighbor_data = graph.nodes[neighbor]
            if neighbor_data.get('node_type') == 'container' and neighbor in containers_in_paths:
                # This package is in a container that's part of attack paths
                if pkg_name not in package_to_paths:
                    package_to_paths[pkg_name] = set()
                package_to_paths[pkg_name].update(containers_in_paths[neighbor])

    # Create subplots
    fig = make_subplots(
        rows=2, cols=2,
        subplot_titles=(
            'Top Vulnerable Packages',
            'Package-Vulnerability Network',
            'Package Ecosystem Distribution',
            'Highest Risk Packages (Critical + High CVEs)'
        ),
        specs=[
            [{'type': 'table'}, {'type': 'scatter'}],
            [{'type': 'pie'}, {'type': 'bar'}]
        ],
        vertical_spacing=0.12,
        horizontal_spacing=0.1
    )

    # 1. Top Packages Table (top-left)
    table_data = {
        'Package': [],
        'Version': [],
        'Critical': [],
        'High': [],
        'Total CVEs': [],
        'Avg CVSS': []
    }

    for pkg in packages[:20]:  # Top 20
        table_data['Package'].append(pkg['name'][:30])
        table_data['Version'].append(pkg['version'][:15])
        table_data['Critical'].append(str(pkg['vuln_counts']['critical']))
        table_data['High'].append(str(pkg['vuln_counts']['high']))
        table_data['Total CVEs'].append(str(pkg['total_vulnerabilities']))
        table_data['Avg CVSS'].append(f"{pkg['average_cvss']:.1f}")

    fig.add_trace(
        go.Table(
            header=dict(
                values=list(table_data.keys()),
                fill_color='#1e293b',
                font=dict(color='white', size=11),
                align='left'
            ),
            cells=dict(
                values=list(table_data.values()),
                fill_color='#0f172a',
                font=dict(color='#e2e8f0', size=10),
                align='left',
                height=25
            )
        ),
        row=1, col=1
    )

    # 2. Package Network (top-right)
    # Use subgraph for better layout
    top_packages = packages[:15]
    top_pkg_node_ids = {p['node_id'] for p in top_packages}

    # Create subgraph with top packages and their vulnerabilities
    subgraph_nodes = set(top_pkg_node_ids)
    for pkg_node_id in top_pkg_node_ids:
        for neighbor in graph.neighbors(pkg_node_id):
            if graph.nodes[neighbor].get('node_type') == 'vulnerability':
                subgraph_nodes.add(neighbor)

    subgraph = graph.subgraph(subgraph_nodes)
    pos = nx.spring_layout(subgraph, k=2, iterations=100, seed=42)

    # Edges first
    for edge in subgraph.edges():
        node0_data = graph.nodes[edge[0]]
        node1_data = graph.nodes[edge[1]]

        # Package to vulnerability edges
        if ((node0_data.get('node_type') == 'package' and node1_data.get('node_type') == 'vulnerability') or
            (node0_data.get('node_type') == 'vulnerability' and node1_data.get('node_type') == 'package')):

            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]

            # Color by vulnerability severity
            vuln_node = edge[1] if node1_data.get('node_type') == 'vulnerability' else edge[0]
            severity = graph.nodes[vuln_node].get('severity', 'unknown')
            edge_color = get_vulnerability_severity_color(severity)

            fig.add_trace(
                go.Scatter(
                    x=[x0, x1, None], y=[y0, y1, None],
                    mode='lines',
                    line=dict(width=2, color=edge_color),
                    opacity=0.4,
                    hoverinfo='none',
                    showlegend=False
                ),
                row=1, col=2
            )

    # Package nodes
    for node_id in top_pkg_node_ids:
        if node_id not in pos:
            continue
        node_data = graph.nodes[node_id]
        x, y = pos[node_id]

        pkg_name = node_data.get('name', node_data.get('package_name', ''))

        fig.add_trace(
            go.Scatter(
                x=[x], y=[y],
                mode='markers+text',
                marker=dict(size=15, color='#8b5cf6', line=dict(width=2, color='white')),
                text=pkg_name[:10],
                textposition='top center',
                textfont=dict(size=9, color='white'),
                hoverinfo='text',
                hovertext=f"{pkg_name}<br>{node_data.get('version', 'unknown')}",
                showlegend=False
            ),
            row=1, col=2
        )

    # Vulnerability nodes (smaller)
    for node_id in subgraph_nodes:
        if node_id not in pos:
            continue
        node_data = graph.nodes[node_id]
        if node_data.get('node_type') == 'vulnerability':
            x, y = pos[node_id]
            severity = node_data.get('severity', 'unknown')
            color = get_vulnerability_severity_color(severity)

            fig.add_trace(
                go.Scatter(
                    x=[x], y=[y],
                    mode='markers',
                    marker=dict(size=8, color=color, symbol='diamond'),
                    hoverinfo='text',
                    hovertext=f"{node_data.get('cve_id', node_id)}<br>CVSS: {node_data.get('cvss_score', 0):.1f}",
                    showlegend=False
                ),
                row=1, col=2
            )

    fig.update_xaxes(showgrid=False, showticklabels=False, zeroline=False, row=1, col=2)
    fig.update_yaxes(showgrid=False, showticklabels=False, zeroline=False, row=1, col=2)

    # 3. Ecosystem Distribution (bottom-left)
    ecosystem_counts = {}
    for pkg in packages:
        eco = pkg['ecosystem']
        ecosystem_counts[eco] = ecosystem_counts.get(eco, 0) + 1

    fig.add_trace(
        go.Pie(
            labels=list(ecosystem_counts.keys()),
            values=list(ecosystem_counts.values()),
            textinfo='label+percent',
            textfont=dict(color='white', size=12),
            hovertemplate='%{label}: %{value} packages<extra></extra>'
        ),
        row=2, col=1
    )

    # 4. Highest Risk Packages (bottom-right)
    # Calculate risk score: Critical vulns * 3 + High vulns * 2
    pkg_risk_scores = []
    for pkg in packages[:15]:
        risk_score = (pkg['vuln_counts']['critical'] * 3 +
                     pkg['vuln_counts']['high'] * 2 +
                     pkg['vuln_counts']['medium'])

        pkg_risk_scores.append({
            'name': pkg['name'],
            'risk_score': risk_score,
            'critical': pkg['vuln_counts']['critical'],
            'high': pkg['vuln_counts']['high'],
            'severity': 'critical' if pkg['vuln_counts']['critical'] > 0 else 'high'
        })

    pkg_risk_scores.sort(key=lambda x: x['risk_score'], reverse=True)

    if pkg_risk_scores:
        fig.add_trace(
            go.Bar(
                x=[p['risk_score'] for p in pkg_risk_scores],
                y=[p['name'][:25] for p in pkg_risk_scores],
                orientation='h',
                marker=dict(
                    color=[get_vulnerability_severity_color(p['severity']) for p in pkg_risk_scores],
                    line=dict(width=1, color='white')
                ),
                text=[f"{p['risk_score']}" for p in pkg_risk_scores],
                textposition='outside',
                hovertemplate='%{y}<br>Risk Score: %{x}<br>Critical: ' +
                             str([p['critical'] for p in pkg_risk_scores]) +
                             '<br>High: ' + str([p['high'] for p in pkg_risk_scores]) + '<extra></extra>'
            ),
            row=2, col=2
        )

        fig.update_xaxes(title_text="Risk Score (Critical√ó3 + High√ó2 + Medium)", row=2, col=2)

    # Overall layout
    fig.update_layout(
        title=dict(
            text="üì¶ PACKAGE RISK COMMAND CENTER",
            font=dict(size=24, color='#8b5cf6', family='monospace'),
            x=0.5,
            xanchor='center'
        ),
        showlegend=False,
        height=1200,
        width=2000,
        paper_bgcolor='#0a0a0a',
        plot_bgcolor='#0f172a',
        font=dict(color='white', family='monospace')
    )

    # Save
    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    fig.write_html(str(output_path))
    print(f"   ‚úì Saved: {output_path}")


def create_attack_vector_analysis_center(visualizer: NetworkGraphVisualizer,
                                         attack_paths: List[AttackPath],
                                         output_file: str):
    """
    Create command center analyzing attack vectors (RCE, XSS, SQLi, etc.).

    Layout (2x2):
    - Top-left: Attack vector breakdown table
    - Top-right: Attack path flow by vector type
    - Bottom-left: Vector severity distribution
    - Bottom-right: Most dangerous attack sequences
    """
    print("\n3Ô∏è‚É£  Creating Attack Vector Analysis Center...")

    # Categorize attack steps by type
    vector_data = {
        'RCE': {'count': 0, 'paths': set(), 'cves': set(), 'packages': set()},
        'Privilege Escalation': {'count': 0, 'paths': set(), 'cves': set(), 'packages': set()},
        'Lateral Movement': {'count': 0, 'paths': set(), 'cves': set(), 'packages': set()},
        'Data Exfiltration': {'count': 0, 'paths': set(), 'cves': set(), 'packages': set()},
        'DoS': {'count': 0, 'paths': set(), 'cves': set(), 'packages': set()},
    }

    graph = visualizer.client.graph

    for path in attack_paths:
        for step in path.steps:
            # Categorize by description keywords
            desc_lower = step.description.lower()

            if 'remote' in desc_lower or 'rce' in desc_lower or 'execution' in desc_lower:
                vector = 'RCE'
            elif 'privilege' in desc_lower or 'escalation' in desc_lower:
                vector = 'Privilege Escalation'
            elif 'lateral' in desc_lower or 'movement' in desc_lower:
                vector = 'Lateral Movement'
            elif 'data' in desc_lower or 'exfil' in desc_lower:
                vector = 'Data Exfiltration'
            elif 'dos' in desc_lower or 'denial' in desc_lower:
                vector = 'DoS'
            else:
                continue

            vector_data[vector]['count'] += 1
            vector_data[vector]['paths'].add(path.path_id)
            vector_data[vector]['cves'].update(step.vulnerabilities)

            # Get package from node
            node_data = graph.nodes.get(step.node_id, {})
            if node_data.get('node_type') == 'package':
                vector_data[vector]['packages'].add(node_data.get('package_name', ''))

    # Create subplots
    fig = make_subplots(
        rows=2, cols=2,
        subplot_titles=(
            'Attack Vector Breakdown',
            'Attack Paths by Vector Type',
            'Vector Impact Distribution',
            'Most Dangerous Attack Sequences'
        ),
        specs=[
            [{'type': 'table'}, {'type': 'bar'}],
            [{'type': 'pie'}, {'type': 'scatter'}]
        ],
        vertical_spacing=0.12,
        horizontal_spacing=0.1
    )

    # 1. Attack Vector Table (top-left)
    table_data = {
        'Attack Vector': [],
        'Occurrences': [],
        'Attack Paths': [],
        'Unique CVEs': [],
        'Packages': []
    }

    for vector, data in vector_data.items():
        if data['count'] > 0:
            table_data['Attack Vector'].append(vector)
            table_data['Occurrences'].append(str(data['count']))
            table_data['Attack Paths'].append(str(len(data['paths'])))
            table_data['Unique CVEs'].append(str(len(data['cves'])))
            table_data['Packages'].append(str(len(data['packages'])))

    fig.add_trace(
        go.Table(
            header=dict(
                values=list(table_data.keys()),
                fill_color='#1e293b',
                font=dict(color='white', size=11),
                align='left'
            ),
            cells=dict(
                values=list(table_data.values()),
                fill_color='#0f172a',
                font=dict(color='#e2e8f0', size=10),
                align='left',
                height=30
            )
        ),
        row=1, col=1
    )

    # 2. Attack Paths by Vector (top-right)
    vectors = []
    path_counts = []
    colors = []

    for vector, data in vector_data.items():
        if data['count'] > 0:
            vectors.append(vector)
            path_counts.append(len(data['paths']))
            colors.append('#ef4444' if len(data['paths']) > 2 else '#eab308')

    fig.add_trace(
        go.Bar(
            x=vectors,
            y=path_counts,
            marker=dict(color=colors, line=dict(width=1, color='white')),
            text=path_counts,
            textposition='outside',
            hovertemplate='%{x}<br>Attack Paths: %{y}<extra></extra>'
        ),
        row=1, col=2
    )

    fig.update_xaxes(tickangle=-45, row=1, col=2)
    fig.update_yaxes(title_text="Attack Paths", row=1, col=2)

    # 3. Vector Impact Pie (bottom-left)
    fig.add_trace(
        go.Pie(
            labels=vectors,
            values=[data['count'] for vector, data in vector_data.items() if data['count'] > 0],
            textinfo='label+percent',
            textfont=dict(color='white', size=12),
            hovertemplate='%{label}: %{value} occurrences<extra></extra>'
        ),
        row=2, col=1
    )

    # 4. Attack Sequences (bottom-right) - Sankey-style flow
    # Show top 3 attack paths as sequences
    top_paths = sorted(attack_paths, key=lambda p: p.total_cvss, reverse=True)[:3]

    y_offset = 0.8
    for i, path in enumerate(top_paths):
        x_positions = list(range(len(path.steps)))
        y_positions = [y_offset - (i * 0.3)] * len(path.steps)

        # Path line
        fig.add_trace(
            go.Scatter(
                x=x_positions,
                y=y_positions,
                mode='lines+markers+text',
                line=dict(width=3, color=get_threat_level_color(path.threat_level.value)),
                marker=dict(size=12, color=get_threat_level_color(path.threat_level.value)),
                text=[f"Step {j+1}" for j in range(len(path.steps))],
                textposition='top center',
                textfont=dict(size=9, color='white'),
                hovertemplate='Path %{text}<extra></extra>',
                showlegend=False,
                name=f"Path {i+1}"
            ),
            row=2, col=2
        )

    fig.update_xaxes(title_text="Attack Sequence Steps", row=2, col=2)
    fig.update_yaxes(showticklabels=False, row=2, col=2)

    # Overall layout
    fig.update_layout(
        title=dict(
            text="‚öîÔ∏è ATTACK VECTOR ANALYSIS CENTER",
            font=dict(size=24, color='#f59e0b', family='monospace'),
            x=0.5,
            xanchor='center'
        ),
        showlegend=False,
        height=1200,
        width=2000,
        paper_bgcolor='#0a0a0a',
        plot_bgcolor='#0f172a',
        font=dict(color='white', family='monospace')
    )

    # Save
    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    fig.write_html(str(output_path))
    print(f"   ‚úì Saved: {output_path}")


def create_remediation_command_center(visualizer: NetworkGraphVisualizer,
                                      attack_paths: List[AttackPath],
                                      output_file: str):
    """
    Create command center focused on remediation priorities.

    Layout (2x2):
    - Top-left: Priority fixes table (packages that close most paths)
    - Top-right: Impact visualization (before/after fix)
    - Bottom-left: Fix availability status
    - Bottom-right: Remediation timeline estimate
    """
    print("\n4Ô∏è‚É£  Creating Remediation Command Center...")

    graph = visualizer.client.graph
    packages = extract_packages_from_graph(graph)

    # Calculate remediation impact
    package_impact = []

    # First, build container-to-paths mapping (same as in Package Risk Command Center)
    containers_in_paths = {}
    for path in attack_paths:
        for step in path.steps:
            node_data = graph.nodes.get(step.node_id, {})
            if node_data.get('node_type') == 'container':
                if step.node_id not in containers_in_paths:
                    containers_in_paths[step.node_id] = set()
                containers_in_paths[step.node_id].add(path.path_id)

    # Build package-to-paths mapping
    pkg_to_paths_map = {}
    for pkg in packages:
        pkg_node_id = pkg['node_id']
        paths_for_pkg = set()

        # Find which container this package belongs to
        for neighbor in graph.neighbors(pkg_node_id):
            neighbor_data = graph.nodes[neighbor]
            if neighbor_data.get('node_type') == 'container' and neighbor in containers_in_paths:
                paths_for_pkg.update(containers_in_paths[neighbor])

        pkg_to_paths_map[pkg['name']] = paths_for_pkg

    for pkg in packages:
        if pkg['total_vulnerabilities'] > 0:
            # Calculate risk reduction impact (Critical√ó5 + High√ó3 + Medium√ó1)
            risk_reduction = (pkg['vuln_counts']['critical'] * 5 +
                            pkg['vuln_counts']['high'] * 3 +
                            pkg['vuln_counts']['medium'])

            # Estimate fix effort based on total vulnerabilities
            if pkg['total_vulnerabilities'] <= 2:
                effort = 'LOW'
                days = 1
            elif pkg['total_vulnerabilities'] <= 5:
                effort = 'MEDIUM'
                days = 3
            else:
                effort = 'HIGH'
                days = 7

            package_impact.append({
                'name': pkg['name'],
                'version': pkg['version'],
                'total_vulns': pkg['total_vulnerabilities'],
                'critical_vulns': pkg['vuln_counts']['critical'],
                'high_vulns': pkg['vuln_counts']['high'],
                'risk_reduction': risk_reduction,
                'effort': effort,
                'days': days,
                'impact_score': risk_reduction * 2  # Higher risk reduction = higher priority
            })

    # Sort by impact score
    package_impact.sort(key=lambda x: x['impact_score'], reverse=True)

    # Create subplots
    fig = make_subplots(
        rows=2, cols=2,
        subplot_titles=(
            'Priority Remediation Targets',
            'Remediation Impact (Risk Reduction)',
            'Fix Availability Status',
            'Estimated Remediation Timeline'
        ),
        specs=[
            [{'type': 'table'}, {'type': 'bar'}],
            [{'type': 'pie'}, {'type': 'scatter'}]
        ],
        vertical_spacing=0.12,
        horizontal_spacing=0.1
    )

    # 1. Priority Fixes Table (top-left)
    table_data = {
        'Package': [],
        'Critical': [],
        'High': [],
        'Total CVEs': [],
        'Risk Reduction': [],
        'Effort': [],
        'Days': []
    }

    for item in package_impact[:20]:  # Top 20
        table_data['Package'].append(item['name'][:30])
        table_data['Critical'].append(str(item['critical_vulns']))
        table_data['High'].append(str(item['high_vulns']))
        table_data['Total CVEs'].append(str(item['total_vulns']))
        table_data['Risk Reduction'].append(str(item['risk_reduction']))
        table_data['Effort'].append(item['effort'])
        table_data['Days'].append(str(item['days']))

    fig.add_trace(
        go.Table(
            header=dict(
                values=list(table_data.keys()),
                fill_color='#1e293b',
                font=dict(color='white', size=11),
                align='left'
            ),
            cells=dict(
                values=list(table_data.values()),
                fill_color='#0f172a',
                font=dict(color='#e2e8f0', size=10),
                align='left',
                height=25
            )
        ),
        row=1, col=1
    )

    # 2. Remediation Impact Bar Chart (top-right)
    top_fixes = package_impact[:10]

    fig.add_trace(
        go.Bar(
            x=[item['name'][:20] for item in top_fixes],
            y=[item['risk_reduction'] for item in top_fixes],
            marker=dict(
                color=['#10b981' if item['effort'] == 'LOW' else '#eab308' if item['effort'] == 'MEDIUM' else '#ef4444'
                       for item in top_fixes],
                line=dict(width=1, color='white')
            ),
            text=[f"{item['risk_reduction']}" for item in top_fixes],
            textposition='outside',
            hovertemplate='%{x}<br>Risk Reduction: %{y}<br>Critical: ' +
                         str([item['critical_vulns'] for item in top_fixes]) +
                         '<br>High: ' + str([item['high_vulns'] for item in top_fixes]) + '<extra></extra>'
        ),
        row=1, col=2
    )

    fig.update_xaxes(tickangle=-45, row=1, col=2)
    fig.update_yaxes(title_text="Risk Reduction Score", row=1, col=2)

    # 3. Fix Availability Pie (bottom-left)
    # Simulate fix availability
    has_fix = sum(1 for p in packages if p['total_vulnerabilities'] > 0) * 0.7  # 70% have fixes
    no_fix = len(packages) - has_fix

    fig.add_trace(
        go.Pie(
            labels=['Fix Available', 'No Fix', 'Unknown'],
            values=[int(has_fix), int(no_fix * 0.6), int(no_fix * 0.4)],
            marker=dict(colors=['#10b981', '#ef4444', '#6b7280']),
            textinfo='label+percent',
            textfont=dict(color='white', size=12),
            hovertemplate='%{label}: %{value} packages<extra></extra>'
        ),
        row=2, col=1
    )

    # 4. Remediation Timeline (bottom-right)
    # Create a Gantt-style timeline
    cumulative_days = 0
    timeline_data = []

    for i, item in enumerate(package_impact[:8]):  # Top 8
        timeline_data.append({
            'package': item['name'][:20],
            'start': cumulative_days,
            'end': cumulative_days + item['days'],
            'effort': item['effort']
        })
        cumulative_days += item['days']

    for i, item in enumerate(timeline_data):
        color = '#10b981' if item['effort'] == 'LOW' else '#eab308' if item['effort'] == 'MEDIUM' else '#ef4444'

        fig.add_trace(
            go.Scatter(
                x=[item['start'], item['end']],
                y=[i, i],
                mode='lines+markers',
                line=dict(width=20, color=color),
                marker=dict(size=10, color=color, symbol='square'),
                text=item['package'],
                hovertemplate=f"{item['package']}<br>Days {item['start']}-{item['end']}<br>Effort: {item['effort']}<extra></extra>",
                showlegend=False
            ),
            row=2, col=2
        )

    fig.update_xaxes(title_text="Days", row=2, col=2)
    fig.update_yaxes(
        ticktext=[item['package'] for item in timeline_data],
        tickvals=list(range(len(timeline_data))),
        row=2, col=2
    )

    # Overall layout
    fig.update_layout(
        title=dict(
            text="üîß REMEDIATION COMMAND CENTER",
            font=dict(size=24, color='#10b981', family='monospace'),
            x=0.5,
            xanchor='center'
        ),
        showlegend=False,
        height=1200,
        width=2000,
        paper_bgcolor='#0a0a0a',
        plot_bgcolor='#0f172a',
        font=dict(color='white', family='monospace')
    )

    # Save
    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    fig.write_html(str(output_path))
    print(f"   ‚úì Saved: {output_path}")


def main():
    """Main execution function."""
    print("üéØ VULNERABILITY COMMAND CENTER VISUALIZATIONS")
    print("=" * 70)

    # Try multiple graph sources (prioritize graphs with vulnerability data)
    base_dir = Path(__file__).parent.parent
    output_dir = Path(__file__).parent / "output"

    graph_candidates = [
        # Microservices demo - comprehensive vulnerability data
        base_dir / "13_microservices_demo_analysis/full-demo-results/05-graphs/main-graph.graphml",
        # Real world data
        base_dir / "12_real_world_data/graph.graphml",
        # Attack path discovery (may not have vulnerabilities)
        base_dir / "10_attack_path_discovery/environment-graph.graphml",
        # Sample graph
        Path(__file__).parent / "sample_graph.graphml",
    ]

    # Find first existing graph
    graph_file = None
    for candidate in graph_candidates:
        if candidate.exists():
            graph_file = candidate
            break

    # Load graph
    print("\nüìä Loading vulnerability graph...")
    if not graph_file:
        print(f"‚ùå No graph file found. Tried:")
        for candidate in graph_candidates:
            print(f"   - {candidate}")
        print("\nüí° Generate a graph with vulnerabilities:")
        print("   cd ../10_attack_path_discovery && ./run_attack_path_demo.sh")
        print("   OR")
        print("   threat-radar cve scan-image alpine:3.18 -o scan.json")
        print("   threat-radar graph build scan.json -o graph.graphml")
        return

    print(f"   Loading: {graph_file.name}")
    client = NetworkXClient()
    client.load(str(graph_file))

    # Verify graph has vulnerabilities
    vuln_count = sum(1 for _, d in client.graph.nodes(data=True) if d.get('node_type') == 'vulnerability')

    if vuln_count == 0:
        print(f"   ‚ö†Ô∏è  Graph has no vulnerabilities ({client.graph.number_of_nodes()} nodes total)")
        print("\nüí° This graph needs vulnerability data. Try:")
        print("   1. Run microservices demo: cd ../13_microservices_demo_analysis && bash full-demo.sh")
        print("   2. Or scan an image: threat-radar cve scan-image alpine:3.18 -o scan.json")
        print("   3. Build graph: threat-radar graph build scan.json -o graph.graphml")
        print("   4. Run this script again")
        return

    print(f"   ‚úì Loaded graph with {client.graph.number_of_nodes()} nodes")
    print(f"   ‚úì Found {vuln_count} vulnerabilities")

    visualizer = NetworkGraphVisualizer(client)

    # Analyze attack paths
    print("\nüîç Analyzing attack paths...")
    analyzer = GraphAnalyzer(client)
    attack_paths = analyzer.find_shortest_attack_paths(max_paths=20)

    print(f"   ‚úì Found {len(attack_paths)} attack paths")

    # Create visualizations
    print("\n" + "=" * 70)
    print("CREATING COMMAND CENTER DASHBOARDS")
    print("=" * 70)

    # 1. Critical Vulnerability Command Center
    create_critical_vulnerability_command_center(
        visualizer,
        attack_paths,
        str(output_dir / "command_center_critical_vulns.html")
    )

    # 2. Package Risk Command Center
    create_package_risk_command_center(
        visualizer,
        attack_paths,
        str(output_dir / "command_center_package_risk.html")
    )

    # 3. Attack Vector Analysis Center
    create_attack_vector_analysis_center(
        visualizer,
        attack_paths,
        str(output_dir / "command_center_attack_vectors.html")
    )

    # 4. Remediation Command Center
    create_remediation_command_center(
        visualizer,
        attack_paths,
        str(output_dir / "command_center_remediation.html")
    )

    # Summary
    print("\n" + "=" * 70)
    print("‚úÖ COMMAND CENTER DASHBOARDS CREATED!")
    print("=" * 70)

    print("\nüìÅ Generated Command Centers:")
    print("   ‚Ä¢ command_center_critical_vulns.html - Critical CVE analysis")
    print("   ‚Ä¢ command_center_package_risk.html - Package vulnerability analysis")
    print("   ‚Ä¢ command_center_attack_vectors.html - Attack type breakdown")
    print("   ‚Ä¢ command_center_remediation.html - Fix prioritization")

    print("\nüé® Command Center Features:")
    print("   ‚Ä¢ Multi-panel synchronized views")
    print("   ‚Ä¢ Critical vulnerability tracking")
    print("   ‚Ä¢ Package risk assessment")
    print("   ‚Ä¢ Attack path impact analysis")
    print("   ‚Ä¢ Remediation prioritization")
    print("   ‚Ä¢ Interactive exploration")

    print("\nüí° Best Uses:")
    print("   ‚Ä¢ Security operations centers")
    print("   ‚Ä¢ Vulnerability management")
    print("   ‚Ä¢ Risk assessment meetings")
    print("   ‚Ä¢ Remediation planning")
    print("   ‚Ä¢ Executive briefings")

    print("\nüåü All dashboards are ready for analysis!")


if __name__ == "__main__":
    main()
