"""Reusable vulnerability scanner for Docker images."""
import logging
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass

from .container_analyzer import ContainerAnalysis
from .nvd_client import NVDClient, CVEItem
from .cve_matcher import CVEMatcher, CVEMatch

logger = logging.getLogger(__name__)


@dataclass
class ScanConfiguration:
    """Configuration for vulnerability scanning."""
    min_confidence: float = 0.75
    max_cve_age_years: Optional[int] = 15
    filter_disputed: bool = True
    cve_search_keywords: Optional[List[Tuple[str, int]]] = None  # [(keyword, limit), ...]
    high_profile_cves: Optional[List[str]] = None  # List of CVE IDs to fetch


class VulnerabilityScanner:
    """Reusable vulnerability scanner for container images."""

    def __init__(self, config: Optional[ScanConfiguration] = None):
        """
        Initialize vulnerability scanner.

        Args:
            config: Scan configuration (uses defaults if not provided)
        """
        self.config = config or ScanConfiguration()
        self.matcher = CVEMatcher(
            min_confidence=self.config.min_confidence,
            max_cve_age_years=self.config.max_cve_age_years,
            filter_disputed=self.config.filter_disputed
        )

    def fetch_cves(
        self,
        keywords: Optional[List[Tuple[str, int]]] = None,
        cve_ids: Optional[List[str]] = None
    ) -> List[CVEItem]:
        """
        Fetch CVEs from NVD API.

        Args:
            keywords: List of (keyword, limit) tuples for searching
            cve_ids: List of specific CVE IDs to fetch

        Returns:
            List of CVE objects
        """
        client = NVDClient()
        all_cves = []

        # Fetch specific CVEs by ID
        if cve_ids:
            logger.info(f"Fetching {len(cve_ids)} high-profile CVEs by ID...")
            for cve_id in cve_ids:
                try:
                    cve = client.get_cve_by_id(cve_id)
                    if cve:
                        all_cves.append(cve)
                        logger.debug(f"Fetched {cve_id}")
                except Exception as e:
                    logger.warning(f"Failed to fetch {cve_id}: {e}")

        # Fetch CVEs by keyword search
        if keywords:
            logger.info(f"Searching CVEs with {len(keywords)} keywords...")
            for keyword, limit in keywords:
                try:
                    cves = client.search_cves(keyword=keyword, results_per_page=limit)
                    all_cves.extend(cves)
                    logger.debug(f"Found {len(cves)} CVEs for '{keyword}'")
                except Exception as e:
                    logger.warning(f"Failed to search '{keyword}': {e}")

        client.close()

        # Remove duplicates
        unique_cves = {cve.cve_id: cve for cve in all_cves if cve}.values()
        return list(unique_cves)

    def scan(
        self,
        analysis: ContainerAnalysis,
        cves: List[CVEItem]
    ) -> Dict[str, List[CVEMatch]]:
        """
        Scan container packages against CVEs.

        Args:
            analysis: Container analysis with package list
            cves: List of CVEs to check against

        Returns:
            Dictionary mapping package names to their CVE matches
        """
        logger.info(f"Scanning {len(analysis.packages)} packages against {len(cves)} CVEs...")
        matches = self.matcher.bulk_match_packages(analysis.packages, cves)

        vulnerable_count = len(matches)
        total_vulns = sum(len(m) for m in matches.values())

        logger.info(f"Found {vulnerable_count} vulnerable packages with {total_vulns} total CVEs")

        return matches

    def calculate_statistics(
        self,
        matches: Dict[str, List[CVEMatch]]
    ) -> Dict:
        """
        Calculate statistics from scan results.

        Args:
            matches: Dictionary of package matches

        Returns:
            Dictionary with statistics
        """
        severity_breakdown = {}
        confidence_stats = {"high": 0, "medium": 0, "low": 0}
        version_match_count = 0
        total_findings = 0

        for pkg_matches in matches.values():
            for match in pkg_matches:
                # Severity
                sev = match.cve.severity or "UNKNOWN"
                severity_breakdown[sev] = severity_breakdown.get(sev, 0) + 1

                # Confidence
                if match.confidence >= 0.90:
                    confidence_stats["high"] += 1
                elif match.confidence >= 0.80:
                    confidence_stats["medium"] += 1
                else:
                    confidence_stats["low"] += 1

                # Version match
                if match.version_match:
                    version_match_count += 1

                total_findings += 1

        return {
            "vulnerable_packages": len(matches),
            "total_vulnerabilities": total_findings,
            "severity_breakdown": severity_breakdown,
            "confidence_stats": confidence_stats,
            "version_match_count": version_match_count,
            "version_match_rate": (version_match_count / total_findings * 100) if total_findings > 0 else 0
        }

    def categorize_findings(
        self,
        matches: Dict[str, List[CVEMatch]]
    ) -> Tuple[List, List, List]:
        """
        Categorize findings into true positives, likely positives, and potential false positives.

        Args:
            matches: Dictionary of package matches

        Returns:
            Tuple of (true_positives, needs_review, potential_false_positives)
            Each list contains tuples of (package_name, cve_id, confidence)
        """
        true_positives = []
        needs_review = []
        potential_false_positives = []

        for pkg_name, pkg_matches in matches.items():
            for match in pkg_matches:
                entry = (pkg_name, match.cve.cve_id, match.confidence)

                if match.version_match and match.confidence >= 0.90:
                    true_positives.append(entry)
                elif match.version_match:
                    needs_review.append(entry)
                else:
                    potential_false_positives.append(entry)

        return true_positives, needs_review, potential_false_positives
