"""AI-powered vulnerability analysis"""

from dataclasses import dataclass, asdict
from typing import List, Dict, Any, Optional
import json

from threat_radar.ai.llm_client import LLMClient, get_llm_client
from threat_radar.ai.prompt_templates import create_analysis_prompt
from threat_radar.core.grype_integration import GrypeScanResult, GrypeVulnerability


@dataclass
class VulnerabilityInsight:
    """AI-generated insight for a single vulnerability"""

    cve_id: str
    package_name: str
    exploitability: str  # HIGH, MEDIUM, LOW
    exploitability_details: str
    attack_vectors: List[str]
    business_impact: str  # HIGH, MEDIUM, LOW
    business_impact_details: str
    recommendations: List[str]


@dataclass
class VulnerabilityAnalysis:
    """Complete AI analysis of vulnerability scan results"""

    vulnerabilities: List[VulnerabilityInsight]
    summary: str
    metadata: Dict[str, Any]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "vulnerabilities": [asdict(v) for v in self.vulnerabilities],
            "summary": self.summary,
            "metadata": self.metadata,
        }


class VulnerabilityAnalyzer:
    """Analyzes vulnerabilities using AI to provide context and insights"""

    def __init__(
        self,
        llm_client: Optional[LLMClient] = None,
        provider: Optional[str] = None,
        model: Optional[str] = None,
    ):
        """
        Initialize vulnerability analyzer.

        Args:
            llm_client: Pre-configured LLM client (optional)
            provider: AI provider if not using pre-configured client
            model: Model name if not using pre-configured client
        """
        self.llm_client = llm_client or get_llm_client(provider=provider, model=model)

    def analyze_scan_result(
        self, scan_result: GrypeScanResult, temperature: float = 0.3
    ) -> VulnerabilityAnalysis:
        """
        Analyze a complete Grype scan result.

        Args:
            scan_result: GrypeScanResult from Grype scan
            temperature: LLM temperature for analysis (lower = more consistent)

        Returns:
            VulnerabilityAnalysis with AI-generated insights
        """
        # Convert Grype vulnerabilities to dict format
        vulnerabilities_data = [self._vuln_to_dict(v) for v in scan_result.vulnerabilities]

        # Generate analysis using AI
        prompt = create_analysis_prompt(vulnerabilities_data)

        try:
            response = self.llm_client.generate_json(prompt, temperature=temperature)

            # Parse response into structured format
            insights = [
                VulnerabilityInsight(**vuln_data)
                for vuln_data in response.get("vulnerabilities", [])
            ]

            metadata = {
                "target": scan_result.target,
                "total_vulnerabilities": scan_result.total_count,
                "severity_counts": scan_result.severity_counts,
                "scan_metadata": scan_result.scan_metadata,
            }

            return VulnerabilityAnalysis(
                vulnerabilities=insights,
                summary=response.get("summary", ""),
                metadata=metadata,
            )

        except Exception as e:
            raise RuntimeError(f"Failed to analyze vulnerabilities: {str(e)}")

    def analyze_vulnerabilities(
        self, vulnerabilities: List[GrypeVulnerability], temperature: float = 0.3
    ) -> VulnerabilityAnalysis:
        """
        Analyze a list of vulnerabilities.

        Args:
            vulnerabilities: List of GrypeVulnerability objects
            temperature: LLM temperature for analysis

        Returns:
            VulnerabilityAnalysis with AI-generated insights
        """
        vulnerabilities_data = [self._vuln_to_dict(v) for v in vulnerabilities]

        prompt = create_analysis_prompt(vulnerabilities_data)

        try:
            response = self.llm_client.generate_json(prompt, temperature=temperature)

            insights = [
                VulnerabilityInsight(**vuln_data)
                for vuln_data in response.get("vulnerabilities", [])
            ]

            # Calculate severity counts
            severity_counts = {}
            for vuln in vulnerabilities:
                severity = vuln.severity.lower()
                severity_counts[severity] = severity_counts.get(severity, 0) + 1

            metadata = {
                "total_vulnerabilities": len(vulnerabilities),
                "severity_counts": severity_counts,
            }

            return VulnerabilityAnalysis(
                vulnerabilities=insights,
                summary=response.get("summary", ""),
                metadata=metadata,
            )

        except Exception as e:
            raise RuntimeError(f"Failed to analyze vulnerabilities: {str(e)}")

    def _vuln_to_dict(self, vuln: GrypeVulnerability) -> Dict[str, Any]:
        """Convert GrypeVulnerability to dictionary"""
        return {
            "id": vuln.id,
            "severity": vuln.severity,
            "package_name": vuln.package_name,
            "package_version": vuln.package_version,
            "package_type": vuln.package_type,
            "fixed_in_version": vuln.fixed_in_version,
            "description": vuln.description,
            "cvss_score": vuln.cvss_score,
            "urls": vuln.urls,
            "data_source": vuln.data_source,
        }

    def get_high_priority_vulnerabilities(
        self, analysis: VulnerabilityAnalysis
    ) -> List[VulnerabilityInsight]:
        """
        Filter vulnerabilities to high priority ones.

        Args:
            analysis: VulnerabilityAnalysis result

        Returns:
            List of high priority vulnerabilities
        """
        return [
            v
            for v in analysis.vulnerabilities
            if v.exploitability == "HIGH" or v.business_impact == "HIGH"
        ]

    def get_critical_paths(self, analysis: VulnerabilityAnalysis) -> List[str]:
        """
        Extract critical attack paths from analysis.

        Args:
            analysis: VulnerabilityAnalysis result

        Returns:
            List of critical attack vector descriptions
        """
        critical_vectors = set()

        for vuln in analysis.vulnerabilities:
            if vuln.exploitability == "HIGH":
                critical_vectors.update(vuln.attack_vectors)

        return list(critical_vectors)
